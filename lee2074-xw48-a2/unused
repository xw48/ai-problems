#!/usr/bin/env python
# pikachu.py : this program is designed to recommend a move for Pikachu game.
# lee2074 & xw48, Feb. 28, 2017
#
# Problem: (how to formulate it)
# State space:
# Successor function:
# Edge weights:
# How search algorithm works:
# Faced problems:
# Assumtions:

import sys
from heapq import heappush, heappop
import numpy as np
import gc
import ast

n = 7

# moving directions for player 'w'
MOVE = {}
MOVE['F'] = (1, 0)
MOVE['B'] = (-1, 0)
MOVE['L'] = (0, 1)
MOVE['R'] = (0, -1)
'''
...
...
...
www
...
...
...
...
bbb
...
...
'''

# add a movement to current board state
def add_move(board, row, row_offset, col, col_offset):
	nboard = [row[:] for row in board]




# get a list of successors
def successors(board, player):
	global n
	succs = []

	for i in range(n):
		for j in range(n):
			if player.lower() != board[i][j].lower():
				continue

			player_tag = 1 if 'w' == player.lower() else -1
			isPichu = board[i][j] == board[i][j].lower()

			if isPichu == True:
				for move in {'F', 'L', 'R'}:
					#one step
					if (i+MOVE[move][0]*player_tag in range(0, n)) and (j+MOVE[move][1]*player_tag in range(0, n)) and board[i+MOVE[move][0]*player_tag][j+MOVE[move][1]*player_tag] == '.':
						succs.append(add_move(board, i, MOVE[move][0]*player_tag, j, MOVE[move][1]*player_tag))
					#two steps
					if (i+2*MOVE[move][0]*player_tag in range(0, n)) and (j+2*MOVE[move][1]*player_tag in range(0, n)) and (board[i+2*MOVE[move][0]*player_tag][j+2*MOVE[move][1]*player_tag] == '.') and (board[i+MOVE[move][0]*player_tag][j+MOVE[move][1]*player_tag].lower == ('w' if player_tag == -1 else 'b')):
						succs.append(add_move(board, i, 2*MOVE[move][0]*player_tag, j, 2*MOVE[move][1]*player_tag))
			else:
				for move in {'F', 'B', 'L', 'R'}:
					max_steps = min(abs(n-1-i if MOVE[move][0]*player_tag == 1 else i if MOVE[move][0]*player_tag == -1 else n), abs(n-1-j if MOVE[move][1]*player_tag == 1 else j if MOVE[move][1]*player_tag == -1 else n))

					for step in range(1, max_steps+1):
						target_pos = (i+step*MOVE[move][0]*player_tag, j+step*MOVE[move][1]*player_tag)
						own_cnt = 0
						opposite_cnt = 0

						for n_i in range(i, target_pos[0] + MOVE[move][0]*player_tag):
							for n_j in range(j, target_pos[1] + MOVE[move][1]*player_tag):
								if board[n_i][n_j].lower() == board[i][j].lower():
									own_cnt += 1
								else if not board[n_i][n_j] == '.':
									opposite_cnt += 1

						if own_cnt > 1 or opposite_cnt > 1:
							continue
						succs.append(add_move(board, i, step*MOVE[move][0]*player_tag, j, step*MOVE[move][1]*player_tag))


if __name__ == '__main__':
	if len(sys.argv) < 5:
		print 'usage:', sys.argv[0], 'n', 'w/b', 'state' 'timeout'
		sys.exit(-1)

	global n
	n = int(sys.argv[1])
	player = sys.argv[2]

	if player != 'w' and player != 'b':
		print 'bad current player format'
		sys.exit(-1)

	timeout = int(sys.argv[4])
	board_state = [[sys.argv[3][i*n+j] for j in range(n)]for i in range(n)]


